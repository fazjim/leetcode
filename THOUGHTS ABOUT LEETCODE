THOUGHTS ABOUT LEETCODE

1.  If too much time complexity from one side, try binary split or merge from sides. (container with water)
2.  Corner cases:
  a) Integer.MAX_VALUE, Integer.MIN_VALUE   judge if over   x >  (Integer.MAX_VALUE- y) / z
3.  Sometimes for easy cases, code lookup will be faster than writing the logic judgements (integer to roman)
4.  Ideas of KMP:  build a prefix table and use the match to increase the strides for moving
The building of KMP prefix table, ABCDABE, then prefix of E is the same of prefix C, so if E does not match, jump to see if C matches (because you know AB already matches)
The time complexity is O(m+n)
5.  ListNode, find a position, using fast and slow pointers
6.  Use of heap/PriorityQueue for n-best problems
7.  Be careful of the overflow cases, for example (a+b)/2, but a+b may overflow, calculate mid as int mid = low + (high - low) / 2(Refer to 2)
8. bitwise operation: ^ XOR,  & and , | or,   << (0010 -> 0100)   >> (0010 -> 0001)
9.  StringBuffer for string operation, setCharAt for changing character
10. to boost program speed, for characters such as "1" , "2", use "1"-'0' to get its index and use the array to avoid the use of Hashtable
11. Just found out that always choose to use HashMap instead of Hashtable
12. CountPrimes,  i*i< n  j = i*i, j+=i
13. When shifting an array, be careful to start from the end so that the shifting of previous elements would not affect the following operations
14. Difference between minDepth and maxDepth, minDepth needs to consider the null child (null child is not the leaf), while maxDepth only needs to consider the max depth (will always ignore the null child)
15. Again, to avoid conflict in in-space array operation, think about whether start from the end
16. Rabin-Karp: Use hash instead of character matching
17. One way to avoid always starting from the first position of a linkedlist is to record the position of last and then do the math
18. Use PriorityQueue to store the min/max value and dynamically updates the queue to get the kth value
19. DP has both top-down and bottom-up solutions!
20. In the application of binary search, be careful of the move of middle to avoid endless loop (Whether start > end)
21. GCD (Global common divisor) can also be viewed as the smallest linear combination of x and y, proof can be found here: https://aakritty.wordpress.com/2014/02/10/solving-the-water-jug-problem/
gcd(x, y) = gcd (y, x-y)   ||  gcd(x, y) == gcd (y, x % y)
